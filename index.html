<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>reveal.js</title>

  <link rel="stylesheet" href="dist/reset.css" />
  <link rel="stylesheet" href="dist/reveal.css" />
  <link rel="stylesheet" href="dist/theme/black.css" />

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/monokai.css" />
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!-- TITLE -->

      <section>
        <section>
          <h1>Saying what you mean</h1>
          <p>How precise language eliminates bugs</p>

          <aside class="notes">
            In South Africa, we dont say ‚Äúhello‚Äù, we say ‚Äúhaazit boet‚Äù, and I
            think it‚Äôs beautiful. This talk is called saying what you mean,
            and I hope that by the end of it, you will think about language in
            a new way, and that you will see programming as an extension of
            that, and that you will have learned a few techniques that allow
            you to manipulate how you express yourself in code to write better
            software.
          </aside>
        </section>

        <section>
          <h2>About me</h2>
          <p>üëãüèª Phlippie Bosman</p>
          <p>ü´∞üèª <a href="https://retrorabbit.co.za">Retro Rabbit</a></p>
          <p>
            üßëüèª‚Äçüíª github.com/<a href="https://github.com/phlippieb">phlippieb</a>
          </p>
          <p>
            üêª
            <a href="https://phlippieb.bearblog.dev">phlippieb</a>.bearblog.dev
          </p>

          <aside class="notes">
            My name is Phlippie. That is my real name. I will not elaborate
            any further. For money, I work as a mobile developer at a cosy
            little software consultancy called Retro Rabbit. I have some stuff
            on Git Hub, and I blog sometimes and put it on bearblog, which is
            a super lightweight blogging platform built by a South African dev
            called Herman Martinus; check it out!
          </aside>
        </section>

        <section>
          <h2>These slides</h2>
          <p>Made with <a href="https://revealjs.com/">reveal js</a></p>
          <p>
            View at
            <a href="https://phlippieb.github.io/saying-what-you-mean">phlippieb.github.io/saying-what-you-mean</a>
          </p>
          <p>
            Source at
            <a href="https://github.com/phlippieb/saying-what-you-mean">github.com/phlippieb/saying-what-you-mean</a>
          </p>

          <aside class="notes">
            I used to be an assistant lecturer and students‚Äô first question
            was always ‚Äúcan we get the slides‚Äù so let‚Äôs get that out of the
            way first. For the curious, these slides were made in reveal.js.
            You can view them at this URL, and the source is on github.
          </aside>
        </section>

        <section>
          <h2>Overview</h2>
          <ol>
            <li>Background: on language</li>
            <li>An opinion</li>
            <li>A tweet</li>
            <li>A concept</li>
          </ol>

          <aside class="notes">
            Here‚Äôs a quick overview of the main points we‚Äôll hit today. (Just
            briefly ready them out)
          </aside>
        </section>
      </section>

      <!-- 1. BACKGROUND -->

      <section data-background="#262227">
        <h2>1. Background</h2>
        <p><i>On language</i></p>

        <aside class="notes">
          It‚Äôs pretty interesting that, as software people, our main tool for
          doing our jobs is <i>language</i>. I mean yes, we use programming
          languages, but they are languages nonetheless. So let‚Äôs talk about
          language for a bit.
        </aside>
      </section>

      <section>
        <h3>Language and technology</h3>
        TODO

        <aside class="notes"></aside>
      </section>

      <section>
        <h3>Language and mind</h3>
        <section>
          <p class="fragment">
            Linguistic relativity (Sapir-Whorf): the structure of a language
            influences its speakers' worldview or cognition, and thus
            individuals' languages determine or influence their perceptions
            of the world (?)
          </p>

          <aside class="notes">
            Any fans in the audience of Denis Villeneuve's sci-fi movie
            Arrival? Without spoiling anything, the movie goes into a
            concept called "linguistic relativity", and even mentions by
            name Sapir and Whorf, the two researchers to whom the idea is
            often attributed. The hypothesis is basically that the language
            that you speak and understand to some degree determines or
            influences your thoughts and your worldview. It's quite an
            intuitive idea if you think about it, and there are lots of
            interesting real-world examples that seem to support it.
          </aside>
        </section>

        <section>
          <ul>
            <li>Pronoun drop: collectivist cultures [1]</li>
            <li>Absolute cardinal directions: improved orientation [2]</li>
            <li>
              Non-agentive language for accidents: less likely to remember
              who caused accidents [2]
            </li>
          </ul>

          <p>
            [1]
            <a
              href="https://courses.lumenlearning.com/waymaker-psychology/chapter/reading-language-and-thought">courses.lumenlearning.com/waymaker-psychology/chapter/reading-language-and-thought</a>
          </p>
          <p>
            [2]
            <a
              href=" https://www.scientificamerican.com/article/how-language-shapes-thought/">www.scientificamerican.com/article/how-language-shapes-thought</a>
          </p>

          <aside class="notes">
            <ul>
              <li>
                Some languages (e.g. Japanese) allow you to drop pronouns;
                instead of saying "I went there", you can just say "went
                there". There seems to be a link between these languages
                where we mention ourselves less frequently, and a more
                collectivist, community-oriented culture.
              </li>
              <li>
                Guugu Yimithirr (language in North Queensland, Australia)
                doesn't have relative directions (like left, right), only
                absolute directions (like north, south). Speakers of these
                languages tend to always know where north is, even when
                they're inside. This is not a skill most others have!
              </li>
              <li>
                Researchers designed an experiment where speakers of
                English, Japanese and Spanish watched videos of people
                breaking things, either by accident or on purpose. Unlike
                English, Japanese and Spanish doesn't use agentive language
                for accidents - instead of saying "john broke the vase",
                they will say "the vase broke". After watching the videos,
                speakers of these languages were equally likely to remember
                who broke something <i>on purpose</i>, but less likely to
                remember who broke something <i>accidentally</i>.
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <ul>
            <li>Time as a resource or a cycle [1]</li>
            <li>Colors - red vs pink; blue vs light blue [1]</li>
            <li>Newspeak, 1984</li>
          </ul>

          <p>
            [1]
            <a
              href="https://www.linguisticsociety.org/content/does-language-i-speak-influence-way-i-think">www.linguisticsociety.org/content/does-language-i-speak-influence-way-i-think</a>
          </p>
          <aside class="notes">
            <ul>
              <li>
                In English, time is "stuff" (two days, three hours). We
                think of it as something that can be saved, wasted, lost,
                spent. In Hopi (Native American language) it is seen as a
                cycle. Can you imagine how this might change your outlook?
              </li>
              <li>
                Even the colour-ignorant among us tend to think of pink as
                its own colour, distinct from red. Is it because it has a
                different name? Russian has different names for darker and
                lighter shades of blue.
              </li>
              <li>
                The idea is also central to the fictional language
                "Newspeak" imposed by the totalitarian government in George
                Orwell's novel 1984. The idea is that, by making the
                populace speak a language without words for rebellion and
                uprising, they won't be able to think about those concepts.
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <p>Wittgenstein:</p>
          <blockquote>
            The limits of my language mean the limits of my world
          </blockquote>
          <p>Kravchenko:</p>
          <blockquote class="r-fit-text">
            An existing impasse in the study of this relationship [‚Ä¶]
            between language and mind [‚Ä¶] cannot be overcome as long as the
            problem itself is not reformulated to rid it of the
            intrinsically dualistic assumption that there is, in fact, a
            phenomenon called ‚Äòlanguage‚Äô that is ontologically independent
            of the phenomenon called ‚Äòmind.‚Äô [‚Ä¶] mind cannot be understood
            without and outside of language.
          </blockquote>
        </section>

        <section>
          Disclaimer: Linguistic determinism probably not real

          <aside class="notes">
            Please note that the strong version of the Sapir Whorf
            hypothesis, aka linguistic determinish, which is that language
            <b>determines</b> thoughts, is pretty much universally rejected
            by linguists; not having a word for something does not restrict
            us from thinking about it. As an example, have you ever said "I
            can't explain how I'm feeling"? However, a looser form of the
            hypothesis really seems to resonate with most people, and be
            supported by empirical evidence. Having or learning a word for a
            concept does seem to help us integrate it into our thinking, and
            more efficiently communicate about that concept with others. We
            might argue that the people in 1984 would still be able to think
            about rebellion, but would have a much harder time organising a
            coup among one another without having the necessary language to
            communicate about it.
          </aside>
        </section>
      </section>
      </section>

      <!-- 2. OPINION: PRECISE LANGUAGE -->

      <section>
        <h2>2. An opinion</h2>
        <p>
          Writing clearly (in code) is a professional responsibility, not an
          optional soft skill.
        </p>
        <p class="fragment">
          Moreover, the process of refining messy code into something clear
          and readable is about more than just writing style; it‚Äôs about
          sorting out your own mental model of the code, organising your
          thoughts, mastering the subject matter, and then putting it down
          clearly, so that others can benefit from your mental efforts.
        </p>

        <aside class="notes">
          So having hopefully convinced you that languge is more than just a necessary evil ‚Äî more than just some
          background medium through which we must wade ‚Äî I hope I can get you onboard with this opinion that I have.
          <br>
          Our job is language. We spend our working days "saying" things, through the act of programming and
          refactoring. And I strongly believe that it doesn't just matter what we say, but that how we say it is vitally
          important.
          <br>
          So as professionals who get paid a fair amount of money, I believe we ought to hold each other accountable for
          mastering the art of language, and writing clearly.
          <br>
          But I want to go deeper and say that it's not just about putting something down in a file that won't make
          others developers hate you when they read it. We've talked about the link between language and mind, and I
          believe that spending the extra effort to find the right way to write a piece of code is about figuring out,
          internally, in your mind, what the code is really trying to say.
        </aside>
      </section>
      </section>

      <!-- 3. A TWEET -->

      <section data-background="#262227">
        <h2>3. A (controversial) tweet</h2>
        TODO

        <aside class="notes"></aside>
      </section>

      <!-- 4. A CONCEPT -->

      <section>
        <h2>4. A concept</h2>
        <p>Making invalid state unrepresentable</p>

        <ol type="a" class="fragment">
          <li>Maybe, Optional, Nullable</li>
          <li>Tagged types</li>
          <li>NonZero, NonEmpty</li>
          <li>Closed sets, discriminated unions</li>
        </ol>

        <aside class="notes">
          Ok, so far this stuff has been a bit airy-fairy-soft-sciency, and this talk pretty much amounts to "write
          clean code". So
          let's make it more interesting and talk about a specific way in which we can use the nuances of language to
          our advantage. I'd like to tell you about a concept called "making invalid state unrepresentable".
          <br>
          Just like how a natural language might lack a word for something, our code might be written in such a way that
          it
          lacks the ability to express something. We can use this to our advantage to make certain bad things impossible
          to write.
          <br>
          The basic concept is: if it is an error (or a bug) for a program to be in a certain state, then you can
          program it to make it impossible to even represent that state. That way, the error literally cannot occur.
          <br>
          This is a little hard to understand in the abstract, so let‚Äôs look at some concrete examples. We're going to
          talk about 4 strategies or concepts:
        </aside>
      </section>

      <!-- ... Maybe, Optional, Nullable -->

      <section>
        <section data-auto-animate>
          <h3>a. Maybe, Optional, Nullable</h3>
          <pre data-id="code-1" class="fragment"><code class="hljs java" data-trim data-line-numbers>
              public class MyClass {
              &nbsp;static String getValue() {
              &nbsp;&nbsp;return "Hello world!";
              &nbsp;}

              &nbsp;public static void main(String args[]) {
              &nbsp;&nbsp;String value = getValue();
              &nbsp;&nbsp;System.out.println(value.toUpperCase());
              &nbsp;&nbsp;// Hello world!
              &nbsp;}
              }
            </code></pre>

          <aside class="notes">
            Ok, so we mentioned ‚Äúinvalid state‚Äù. What kind of invalid state are we talking about? Let's look at a simple
            example, especially if you've ever worked in Java or C++. Here's some innocent Java code...


          </aside>
        </section>

        <section data-auto-animate>
          <pre data-id="code-1"><code class="hljs java" data-trim data-line-numbers="3,9">
              public class MyClass {
              &nbsp;static String getValue() {
              &nbsp;&nbsp;return null;
              &nbsp;}

              &nbsp;public static void main(String args[]) {
              &nbsp;&nbsp;String value = getValue();
              &nbsp;&nbsp;System.out.println(value.toUpperCase());
              &nbsp;&nbsp;// Exception in thread "main" java.lang.NullPointerException
              &nbsp;}
              }
            </code></pre>

          <aside class="notes">
            If we just change the content of our function to return null, we get this error that might give you some
            mild PTSD: ‚ÄúNullPointerException‚Äù. The interesting thing here is that, from a syntax point of view, Java
            says it's totally allowed and correct to return null from a function that says on the tin it will return a
            string.
            <br>
            One way to look at the problem is that, in languages like Java and C++ and even Go (sorry Go fanboys), for
            many types, a value can either be present or it can be null. A lot of the time, we don‚Äôt actually want those
            values to be null when we use them. I mean this in the sense that we don‚Äôt usually assign a special, valid
            meaning to the case where a value is null. Null is often simply an invalid state. Yes, you write your checks
            for it, so if your program is relatively well-written, you shouldn‚Äôt see runtime exceptions. But let's look
            beyond the semantic level: Can we make that invalid state unrepresentable at the type level
            instead, so that writing
            a check doesn‚Äôt for null even make sense?
            <br>
            We can! But not necessarily in Java. I said this was an easy example, not a good one.
          </aside>
        </section>

        <section data-auto-animate>
          <h3>The Maybe monad</h3>
          <p>(Understanding monads: <a href="https://www.youtube.com/watch?v=C2w45qRc3aU">
              https://youtu.be/C2w45qRc3aU</a>)</p>

          <aside class="notes">
            Many modern languages provide some version of the Maybe monad. I‚Äôm not going to try and explain what a
            monad
            is (but it‚Äôs actually not so complicated, and here is a link to video that explains is very well). We‚Äôll
            just talk about ‚Äúmaybe‚Äù.
          </aside>
        </section>

        <section data-auto-animate>
          <pre data-id="code-2"><code class="hljs swift" data-line-numbers="1-5|7-12|14-15">
              enum Maybe&lt;T> {
              &nbsp;case some(T)
              &nbsp;case none
              }

              func foo(value: Maybe&lt;String>) {
              &nbsp;switch value {
              &nbsp;case .some(let someValue): print(someValue.uppercased)
              &nbsp;case .none: print("nil")
              &nbsp;}
              }

              foo(value: .some("hello world"))
              foo(value: .none)
            </code></pre>

          <aside class="notes">
            Maybe is a special wrapper type for other types. When a value, for example an int, is wrapped in a Maybe, an
            instance of that Maybe can either be an instance of that value (an int) or it can be null.
            <br>
            Here, we see how a Maybe might be implemented in a language like Swift. It's a simple "either" wrapper type
            ‚Äî an instance of a maybe will either contain a wrapped value of T, or it will contain nothing, or none.
            <br>
            Using it, if a function considers null to be a valid case, it can accept an instance of a Maybe as an
            argument. It can then switch over the received value to either unwrap the wrapped value, if it exists, or
            handle null.
            <br>
            We can call this function with either a wrapped value, or with null.
          </aside>
        </section>

        <section data-auto-animate>
          <pre data-id="code-2"><code class="hljs swift" data-line-numbers="7|8-10|13-15">
              enum Maybe&lt;T> {
              &nbsp;case some(T)
              &nbsp;case none
              }

              func foo(value: String) {
              &nbsp;// No null-handling needed;
              &nbsp;// value is guaranteed to exist
              &nbsp;print(someValue.uppercased)
              }

              foo(value: "hello world")
              // foo(value: .none) ‚¨ÖÔ∏é not even valid Swift syntax
            </code></pre>

          <aside class="notes">
            Now, let's change our function to accept a normal Int, so no longer a maybe.
            <br>
            In the body of the function, we no longer need to handle the null case. Since the argument is not a maybe,
            we are guaranteed by the type system and the compiler that the value will not be null!
            <br>
            At the callsite, we can now only call the function with a non-null value. Trying to pass null is simply not
            valid Swift syntax and it won't compile.
            <br>
            So firstly, this means that the invalid state (null) literally cannot be represented - it is invalid code
            and will throw a compile error. And secondly, when we *do* want null to represent a special case, we have to
            make it explicit, meaning that other developers reading the code can see that something can be intentionally
            made null.
          </aside>
        </section>

        <section>
          <ul>
            <li>Swift: Optional (let x: Int? = 2)</li>
            <li>Kotlin: Nullable (val x: Int? = 2)</li>
            <li>Dart: Nullable (int? x = 2)</li>
            <li>C#: Nullable (int? x = 2)</li>
            <li>Rust: Option (let x: Option&lt;u32> = Some(2))</li>
          </ul>

          <aside class="notes">
            This functionality is actually built into Swift, and maybe types are called "optional". Other major
            languages that support this concept are Kotlin, Dart, C#, Rust, and probably most functional languages.
          </aside>
        </section>
      </section>


      <!-- ... Tagged types -->

      <section>
        <section>
          <h3>b. Tagged types</h3>

          <aside class="notes">
            Let's look at another kind of invalid state, and how we can make it unrepresentable by using something called "tagged types".
          </aside>
        </section>

        <section data-auto-animate>
          <pre data-id="code-tagged-1"><code class="hljs swift" data-line-numbers>
  struct User {
    let id: String
    let name: String
  }

  struct Post {
    let id: String
    let text: String
  }

  func remove(id: String) { ... }
            </code></pre>

          <aside class="notes">
            Here's a code sample. We have two structs that represent entities in our domain level for users and posts. And we have this function to remove a user that accepts a string representing the user's ID. Can you see how we might put it into an invalid state?
          </aside>
        </section>

        <section data-auto-animate>
          <pre data-id="code-tagged-1"><code class="hljs swift" data-line-numbers="13,14">struct User {
  let id: String
  let name: String
}

struct Post {
  let id: String
  let text: String
}

func remove(id: String) { ... }

remove(id: user.id) // ‚úÖ Valid
remove(id: post.id) // ‚ùå Valid, but wrong
            </code></pre>

          <aside class="notes">
            We can call remove with an id for the wrong thing. This is an obvious bug, but it's one that is allowed by the way we wrote the code.
            <br/>
            Now in this example, we can probably just give the remove function a better name, or better yet, choose a better argument label. But let's look a little deeper.
            <br/>
            Another way to look at the problem is that we're using the same type, String,to represent the IDs of both users and posts. We're subconsciously signalling that these IDs are interchangeable; after all, any argument that accepts a user ID will also accept a post ID. What can we change?
          </aside>
        </section>

        <section>
          <pre data-id="code-tagged-2"><code class="hljs swift" data-line-numbers="">func delay(_ work: () -> Void, by seconds: Int) {
    // ...
}

extension Int {
    static let standardDelayTimeInMilliseconds: Int = 1000
}

func testDelay() {
    delay({ print("hi") }, by: .standardDelayTimeInMilliseconds)
}
          </code></pre>

          <aside class="notes">
            Here's another example where changing the naming is maybe not such an elegant solution. The delay function accepts a delay time which is <b>assumed</b> to be in seconds, but nothing prevents us from passing a value that represents milliseconds.
            <br/>
            Another way to think of this problem is that the differentiation between seconds and milliseconds only exists in the semantic level. By reading the words in the functions, we will hopefully see that the method is meant to deal with seconds, and that the constant is meant to be used as milliseconds. If we want to make this more robust, we could elevate the differentiation to the type level.
            <br/>
            As a simple approach, we could just create distinct subclasses for each semantic concept ‚Äî i.e. create a subclass of Int for seconds and another subclass for milliseconds ‚Äî so that the types are not equivalient. However:
            <ul>
              <li>this isn‚Äôt always possible (e.g. in Swift, you can‚Äôt subclass String or Int or UUID). And</li>
              <li>if we follow this approach dogmatically, we‚Äôll quickly pollute the global namespace with all these types.</li>
            </ul>
          </aside>
        </section>

        <section data-auto-animate>
          <pre data-id="code-tagged-3"><code class="hljs swift" data-line-numbers>struct Tagged&lt;Tag, RawValue> {
  var rawValue: RawValue
}
          </code></pre>
<a href="https://github.com/pointfreeco/swift-tagged">github.com/pointfreeco/swift-tagged</a>
          <aside class="notes">
            We can refine the idea but introducing a new helper struct that lets us "tag" simple types as being specific to other types.
          </aside>
        </section>

        <section data-auto-animate>
          <pre data-id="code-tagged-3"><code class="hljs swift" data-line-numbers="12|6,7|16|18,19">struct Tagged&lt;Tag, RawValue> {
  var rawValue: RawValue
}

struct User {
  typealias ID = Tagged&lt;User, String>
  let id: ID
  let name: String
}

struct Post {
  let id: Tagged&lt;Post, String>
  let text: String
}

func remove(id: User.ID) { ... }

remove(id: user.id) // ‚úÖ Valid
//remove(id: post.id) // ‚úÖ Doesn't compile
          </code></pre>

          <aside class="notes">
            Here is how we use it. Instead of using a raw string as an ID, we use a string that was tagged to the user or post type. From a type system point of view, this means ID has a unique type that is not interchangeable with normal strings or with other tagged types.
            <br/>
            For ease of use we can define a little alias for the type.
            <br/>
            Then at the function, we just accept this special type instead of a general string. This gives us type-safety, in that you can't call this function with the wrong kind of ID, and also in terms of just reading the code, this makes it very clear what this function expects.
            <br/>
            Then lastly at the call site, we're allowed to call the function with a valid user ID, but if we try to pass a post ID, it simply won't compile because the type doesn't match. We get compile-level checking that our code is correct, and a bug that was previously possible is now unrepresentable.
          </aside>
        </section>

        <section>
          <pre data-id="code-tagged-3"><code class="hljs swift" data-line-numbers="1-5|7-9|11-13|17-19">enum SecondsTag {}
typealias Seconds = Tagged&lt;SecondsTag, Double>

enum MillisecondsTag {}
typealias Milliseconds = Tagged&lt;MillisecondsTag, Double>

func delay(_ work: () -> Void, by seconds: Seconds) {
// ...
}

extension Milliseconds {
  static let standardDelayTimeInMilliseconds
    = Milliseconds(rawValue: 1000)
}

func testDelay() {
  delay({ print("hi") },
        by: .standardDelayTimeInMilliseconds)
  // ‚úÖ Doesn't compile at all!
}
          </code></pre>
          <aside class="notes">
            Let's wrap it up by looking at the seconds/milliseconds problem. A type can be tagged to a specific type, such as a model like in the previous example, or it can be tagged to a lightweight representational type.
            <br/>
            Here, we defined empty enums (which is idiomatic in Swift) tags for seconds and milliseconds, and then made typealiases for Double values tagged to those types. Note that both Seconds and Milliseconds wrap Double, but they're not interchangeable!
            <br/>
            We change the delay function to explicitly only accept our tagged type for Seconds, and we change the Int extension so that our standard delay time constant returns a tagged type for milliseconds.
            <br/>
            And now of course, when we try to call the delay function with milliseconds, it is not just a logic error but also a compile error.
          </aside>
        </section>
      </section>
    </div>
  </div>





























  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
    });
  </script>
</body>

</html>
