<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        
        <!-- INTRO -->

        <section>
          <section>
            <h1>Saying what you mean</h1>
            <p>How precise language eliminates bugs</p>
            <aside class="notes">
              In South Africa, we dont say ‚Äúhello‚Äù, we say ‚Äúhaazit boet‚Äù, and I
              think that‚Äôs beautiful. This talk is called saying what you mean,
              and my hope is that by the end of it, you will think about language in
              a new way, and that you will see programming as an extension of
              that, and that you will have learned a few techniques that allow
              you to manipulate how you express ideas in code to write better
              software.
            </aside>
          </section>

          <section>
            <h2>These slides</h2>
            <p>
              View at
              <a href="https://phlippieb.github.io/saying-what-you-mean"
                >phlippieb.github.io/saying-what-you-mean</a
              >
            </p>
            <p>Made with <a href="https://revealjs.com/">reveal js</a></p>
            <aside class="notes">
              I used to be an assistant lecturer and whenever I presented something, students‚Äô first question
              was always ‚Äúcan we get the slides‚Äù so let‚Äôs get that out of the
              way first. You can view them at this URL on your screen, so maybe take a screenshot or a photo.
              <br>
              For the curious, these slides were made in reveal.js.
            </aside>
          </section>

          <section>
            <h2>About me</h2>
            <p>üëãüèª Phlippie Bosman</p>
            <p>ü´∞üèª <a href="https://retrorabbit.co.za">Retro Rabbit</a></p>
            <p>
              üßëüèª‚Äçüíª github.com/<a href="https://github.com/phlippieb">phlippieb</a>
            </p>
            <p>
              üêª
              <a href="https://phlippieb.bearblog.dev">phlippieb</a
              >.bearblog.dev
            </p>
            <aside class="notes">
              My name is Phlippie. That is my real name. I will not elaborate
              any further. 
              <br>
              For money, I work as a mobile developer at a cosy
              little software consultancy called Retro Rabbit. I have some stuff
              on The Git Hub, and I blog sometimes and put it on bearblog, which is
              a lightweight blogging platform built by a South African dev
              called Herman Martinus.
            </aside>
          </section>

          <section>
            <h2>Overview</h2>
            <ol>
              <li>On language</li>
              <li>An opinion</li>
              <li>A concept in programming</li>
            </ol>
            <aside class="notes">
              Here‚Äôs a quick overview of the main points we‚Äôll hit today. (Just
              briefly ready them out)
            </aside>
          </section>
        </section>

        <!-- 1. BACKGROUND -->

        <section data-background="#262227">
          <section>
            <h2>1. Background</h2>
            <p><i>On language... and the mind</i></p>
            <p class="fragment">
              Linguistic relativity (Sapir-Whorf): the structure of a language
              influences its speakers' worldview or cognition, and thus
              individuals' languages determine or influence their perceptions of
              the world (?)
            </p>
            <aside class="notes">
              It‚Äôs pretty interesting that, as software people, our main tool
              for doing our jobs is <i>language</i>. I mean yes, 
              <i>programming</i> languages, but languages nonetheless. So
              let‚Äôs talk about language for a bit.
              <br />
              (Press down)
              I'm guessing there are at least a few fans in the audience of Denis Villeneuve's sci-fi movie
              Arrival? Without spoiling anything, the movie goes into a concept
              called "linguistic relativity", and even mentions by name Sapir
              and Whorf, the two researchers to whom the idea is often
              attributed. The hypothesis is basically that the language that you
              speak and understand to some degree determines or influences your
              thoughts and your worldview. It's quite an intuitive idea if you
              think about it, and there are lots of interesting real-world
              examples that seem to support it. For example...
            </aside>
          </section>

          <section>
            <ul>
              <li>Pronoun drop: collectivist cultures [1]</li>
              <li>Absolute cardinal directions: improved orientation [2]</li>
              <li>
                Non-agentive language for accidents: less likely to remember who
                caused accidents [2]
              </li>
            </ul>
            <p>
              [1]
              <a
                href="https://courses.lumenlearning.com/waymaker-psychology/chapter/reading-language-and-thought"
                >courses.lumenlearning.com/waymaker-psychology/chapter/reading-language-and-thought</a
              >
            </p>
            <p>
              [2]
              <a
                href=" https://www.scientificamerican.com/article/how-language-shapes-thought/"
                >www.scientificamerican.com/article/how-language-shapes-thought</a
              >
            </p>
            <aside class="notes">
              <ul>
                <li>
                  Some languages (e.g. Japanese) allow you to drop pronouns;
                  instead of saying "I went there", you can just say "went
                  there". There seems to be a link between these languages where
                  we mention ourselves less frequently, and a more collectivist,
                  community-oriented culture.
                </li>
                <li>
                  A language called Guugu Yimithirr, spoken in North Queensland, Australia,
                  doesn't have relative directions (like left, right), only
                  absolute directions (like north, south). Speakers of these
                  languages tend to always know where north is, even when
                  they're inside a building. This is not a skill most people have!
                </li>
                <li>
                  Researchers designed an experiment where speakers of English,
                  Japanese and Spanish watched videos of people breaking things,
                  either by accident or on purpose.Afterwards, they were asked
                  to recall who broke what. Now unlike English, Japanese and
                  Spanish doesn't use agentive language for accidents - instead
                  of saying "john broke the vase", they will say "the vase was
                  broken". After watching the videos, speakers of these languages
                  were still equally likely to remember who broke something
                  <i>on purpose</i>, but less likely to remember who broke
                  something <i>accidentally</i>.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <ul>
              <li>Time as a resource or a cycle [1]</li>
              <li>Colors - red vs pink; blue vs light blue [1]</li>
              <li>Newspeak, 1984</li>
            </ul>
            <p>
              [1]
              <a
                href="https://www.linguisticsociety.org/content/does-language-i-speak-influence-way-i-think"
                >www.linguisticsociety.org/content/does-language-i-speak-influence-way-i-think</a
              >
            </p>
            <aside class="notes">
              <ul>
                <li>
                  In English, time is "stuff" (two days, three hours). We think
                  of it as something that can be saved, wasted, lost, spent. In
                  other languages, such as Hopi (Native American language) it is seen as a cycle. Can you
                  imagine how this might change your outlook?
                </li>
                <li>
                  Then, talking about colour:
                  Even the colour-ignorant among us (that's me) tend to think of pink as its
                  own colour, distinct from red. Is it because it has a
                  different name? Russian has different names for darker and
                  lighter shades of blue; do russians think of those as distinct colours?
                </li>
                <li>
                  The idea also features in George Orwell's novel 1984, 
                  where a totalitarian government invents a language called 
                  "newspeak" and forces its populace to use it.
                  The idea is that, by making the populace speak a
                  language without words for rebellion and uprising, they won't
                  be able to think about those concepts, and they won't be able
                  to rebel.
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <p>Wittgenstein:</p>
            <blockquote>
              The limits of my language mean the limits of my world
            </blockquote>
            <p>Kravchenko:</p>
            <blockquote class="r-fit-text">
              An existing impasse in the study of this relationship [‚Ä¶] between
              language and mind [‚Ä¶] cannot be overcome as long as the problem
              itself is not reformulated to rid it of the intrinsically
              dualistic assumption that there is, in fact, a phenomenon called
              ‚Äòlanguage‚Äô that is ontologically independent of the phenomenon
              called ‚Äòmind.‚Äô [‚Ä¶] mind cannot be understood without and outside
              of language.
            </blockquote>
          </section>

          <section>
            Disclaimer: Linguistic determinism probably not real
            <aside class="notes">
              Please note that the strong version of the Sapir Whorf hypothesis,
              aka linguistic determinatuion, which is that language
              <b>determines</b> thoughts, is pretty much universally rejected by
              linguists; not having a word for something does not restrict us
              from thinking about it. As an example, have you ever said "I can't
              explain how I'm feeling"? However, a looser form of the hypothesis
              really seems to resonate with most people, and be supported by
              empirical evidence. Having or learning a word for a concept does
              seem to help us integrate it into our thinking, and more
              efficiently communicate about that concept with others. We might
              argue that the people in 1984 would still be able to think about
              rebellion, but would have a much harder time organising a coup
              among one another without having the necessary language to
              communicate about it.
            </aside>
          </section>
        </section>

        <!-- 2. OPINION: PRECISE LANGUAGE -->

        <section>
          <h2>2. An opinion</h2>
          <p>
            Writing clearly (in code) is a professional responsibility, not an
            optional soft skill.
          </p>
          <p class="fragment">
            Moreover, the process of refining messy code into something clear
            and readable is about more than just writing style; it‚Äôs about
            sorting out your own mental model of the code, organising your
            thoughts, mastering the subject matter, and then putting it down
            clearly, so that others can benefit from your mental efforts.
          </p>
          <aside class="notes">
            So having hopefully convinced you that languge is more than just a
            necessary evil ‚Äî more than just some background medium through which
            we must wade ‚Äî I hope I can get you onboard with this opinion that I
            have.
            <br />
            Our job is language. We spend our working days "saying" things,
            through the act of programming and refactoring. And I strongly
            believe that it doesn't just matter what we say, but that how we say
            it is vitally important.
            <br />
            So as professionals who get paid a fair amount of money, I believe
            we ought to hold each other accountable for mastering the art of
            language, and writing clearly.
            <br />
            But I want to go deeper and say that it's not just about putting
            something down in a file that won't make others developers hate you
            when they read it. We've talked about the link between language and
            mind, and I believe that spending the extra effort to find the right
            way to write a piece of code is about figuring out, internally, in
            your own mind, what the code is really trying to say.
          </aside>
        </section>

        <!-- 3. A CONCEPT -->

        <section>
          <h2>3. A concept in programming</h2>
          <p>Making invalid state unrepresentable</p>

          <p class="fragment">
            a. Tagged types<br />
            b. NonEmpty<br />
            c. Closed sets, discriminated unions<br />
          </p>

          <aside class="notes">
            Ok, so far this stuff has been a bit airy-fairy-soft-sciency, and
            this talk pretty much amounts to "write clean code", which isn't exactly a radical message.
            So let's make
            it more interesting and talk about a specific way in which we can
            use the nuances of language to our advantage. I'd like to tell you
            about a concept called "making invalid state unrepresentable".
            <br />
            Just like how a natural language might lack a word for something,
            our code might be written in such a way that it lacks the ability to
            express something. We can use this to our advantage to make certain
            bad things impossible to write.
            <br />
            This is a little hard to understand in the abstract, so let‚Äôs look
            at some concrete examples. We're going to talk about 3 strategies or
            concepts:
          </aside>
        </section>

        <!-- ... Tagged types -->

        <section>
          <section>
            <h3>a. Tagged types</h3>
            <aside class="notes">
              So we mentioned "invalid state". What is that? Here's an example
              of code that can be put into invalid state, that we can fix by
              using something called "tagged types".
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-tagged-1"
            ><code class="hljs swift" data-line-numbers>struct User {
  let id: String
  let name: String
}

struct Post {
  let id: String
  let text: String
}

func remove(id: String) { ... }
            </code></pre>
            <aside class="notes">
              Here's a code sample. We have two structs that represent entities
              in our domain level for users and posts. And we have this function
              to remove a user that accepts a string representing the user's ID.
              Can you see how we might put the function into an invalid state?
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-tagged-1"
            ><code class="hljs swift" data-line-numbers="13,14">struct User {
  let id: String
  let name: String
}

struct Post {
  let id: String
  let text: String
}

func remove(id: String) { ... }

remove(id: user.id) // ‚úÖ Valid
remove(id: post.id) // ‚ùå Valid, but wrong
            </code></pre>
            <aside class="notes">
              Yep! We can call remove with an id for the wrong thing. This is an
              obvious bug, but it's one that we allow by the way we wrote the
              code.
              <br />
              Now in this example, we can probably just give the remove function
              a better name, or a better argument label. But
              let's look a little deeper.
              <br />
              Another way to look at the problem is that we're using the same
              type, String, to represent the IDs of both users and posts. We're
              subconsciously signalling that these IDs are interchangeable;
              after all, any argument that accepts a user ID will also accept a
              post ID. 
            </aside>
          </section>

          <section>
            <pre
              data-id="code-tagged-2"
            ><code class="hljs swift" data-line-numbers="">func delay(_ work: () -> Void, by seconds: Double) {
    // ...
}

extension Double {
    static let standardDelayTimeInMilliseconds: Double = 1000
}

delay({ print("hi") }, by: .standardDelayTimeInMilliseconds)
          </code></pre>
            <aside class="notes">
              Here's another example.
              The delay function accepts a delay time of type Double which
              is <b>assumed</b> to be in seconds, but nothing prevents us from
              passing a Double value that represents milliseconds.
              <br />
              Another way to think of this problem is that the differentiation
              between seconds and milliseconds only exists in the semantic
              level. By reading the words in the functions, we will hopefully
              see that the method is meant to deal with seconds, and that the
              constant is meant to be used as milliseconds. If we want to make
              this more robust, we could elevate the differentiation to the type
              level.
              <br />
              As a simple approach, we could just create distinct subclasses for
              each semantic concept ‚Äî i.e. create a subclass of Double for seconds
              and another subclass for milliseconds ‚Äî so that the types are not
              equivalient. However:
                this isn‚Äôt always possible (e.g. in Swift, you can‚Äôt subclass
                String or Double or UUID) because they're not classes.  And
                if we follow this approach dogmatically, we‚Äôll quickly pollute
                the global namespace with all these types.
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-tagged-3"
            ><code class="hljs swift" data-line-numbers>struct Tagged&lt;Tag, RawValue> {
  var rawValue: RawValue
}
          </code></pre>
            <a href="https://github.com/pointfreeco/swift-tagged"
              >github.com/pointfreeco/swift-tagged</a
            >
            <aside class="notes">
              We can refine the idea of making special types by  introducing a new helper struct that
              lets us "tag" simple types as being specific to other types.
              This idea comes from a site called Pointfree, and they have a library that provides this 
              functionality at the link on the screen.
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-tagged-3"
            ><code class="hljs swift" data-line-numbers="12|6,7|16|18,19">struct Tagged&lt;Tag, RawValue> {
  var rawValue: RawValue
}

struct User {
  typealias ID = Tagged&lt;User, String>
  let id: ID
  let name: String
}

struct Post {
  let id: Tagged&lt;Post, String>
  let text: String
}

func remove(id: User.ID) { ... }

remove(id: user.id) // ‚úÖ Valid
//remove(id: post.id) // ‚úÖ Doesn't compile
          </code></pre>
            <aside class="notes">
              Here is how we use it. Instead of using a raw string as an ID, we
              use a string that was tagged to the user or post type. From a type
              system point of view, this means ID has a unique type that is not
              interchangeable with normal strings or with other tagged types.
              <br />
              For ease of use we can define a little alias for the type.
              <br />
              Then at the function, we just accept this special type instead of
              a raw string. This gives us type-safety, in that you can't
              call this function with the wrong kind of ID, and also in terms of
              just reading the code, this makes it very clear what this function
              expects.
              <br />
              Then lastly at the call site, we're allowed to call the function
              with a valid user ID, but if we try to pass a post ID, it simply
              won't compile because the type doesn't match. The compiler
              checks that our code is correct, and a bug that was previously
              possible is now unrepresentable.
            </aside>
          </section>

          <section>
            <pre
              data-id="code-tagged-3"
            ><code class="hljs swift" data-line-numbers="1-5|7-9|11-13|17-19">enum SecondsTag {}
typealias Seconds = Tagged&lt;SecondsTag, Double>

enum MillisecondsTag {}
typealias Milliseconds = Tagged&lt;MillisecondsTag, Double>

func delay(_ work: () -> Void, by seconds: Seconds) {
// ...
}

extension Milliseconds {
  static let standardDelayTimeInMilliseconds
    = Milliseconds(rawValue: 1000)
}

// delay({ print("hi") }, by: .standardDelayTimeInMilliseconds)
// ‚úÖ Doesn't compile at all!
          </code></pre>
            <aside class="notes">
              Back to the seconds/milliseconds problem. As we saw, a
              type can be tagged to a specific type, such as a model like in the
              previous example, or it can be tagged to a lightweight
              representational type.
              <br />
              Here, we defined empty enums (which is idiomatic in Swift for simple empty types) as tags
              for seconds and milliseconds, and then made typealiases for Double
              values tagged to those types. Note that both Seconds and
              Milliseconds wrap Double, but they're not interchangeable!
              <br />
              We change the delay function to explicitly only accept our tagged
              type for Seconds, and we change the constant so that our
              standard delay time returns a tagged type for
              milliseconds.
              <br />
              And now of course, when we try to call the delay function with
              milliseconds, it is not just a logic error but also a compile
              error.
            </aside>
          </section>
        </section>

        <!-- ... NonEmpty -->

        <section>
          <section>
            <h3>b. NonEmpty</h3>

            <aside class="notes">
              Another day, another kind of invalid state.
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="nonneg-1"
            ><code class="jshl swift" data-line-numbers>func increment(in array: [Int], at index: Int) {
  array[index] = array[index] + 1
}</code></pre>
            <aside class="notes">
              How can we get this function in an invalid state?
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="nonneg-1"
            ><code class="jshl swift" data-line-numbers>func increment(in array: [Int], at index: Int) {
  array[index] = array[index] + 1
}

increment(in: [1, 2, 3], at: -1)
          </code></pre>
            <aside class="notes">
              Right, whenever we pass an index somewhere, we implicitly expect
              that index to be non-zero.
              <br />
              Lots of languages provide special types for list indices, so that
              would be the best for precisely describing our intent.
              Alternatively, we could use an unsigned number type to signify that
              the value can‚Äôt be negative:
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="nonneg-1"
            ><code class="jshl swift" data-line-numbers="1|5,6">func increment(in array: [Int], at index: UInt) {
  array[index] = array[index] + 1
}

increment(in: [1, 2, 3], at: -1)
// ‚úÖ Compile error: Expected value of type UInt</code></pre>
            <aside class="notes">
              Nice and easy. Moving on to something more interesting...
            </aside>
          </section>

          <section>
            <pre
              data-id="nonempty-1"
            ><code class="hljs swift" data-line-numbers>func average(of list: [Double]) -> Double {
  list.reduce(0, +) / list.count
}
          </code></pre>
            <aside class="notes">
              Here's a function that computes the average of an array of numbers.
              How can we break this function?
              <br />
              Hint - what happens if we call it with an empty list?
              <br />
              The average value of an empty list is undefined, because we'd be dividing by zero.
              So maybe we can
              make it unrepresentable to call it with an empty list.
              Let's try!
               Let's define a NonEmptyList. This will be
              almost like a normal list, but it can never be empty! How do we do
              that? What property does a non-empty list have?
            </aside>
          </section>

          <section>
            <pre
              data-id="nonempty-1"
            ><code class="hljs swift" data-line-numbers>struct NonEmptyList&lt;T> {
  let head: T
  let tail: [T]
}
          </code></pre>
            <a href="https://github.com/pointfreeco/swift-nonempty"
              >github.com/pointfreeco/swift-nonempty</a
            >
            <aside class="notes">
              A non-empty list will always have at least one element - a head,
              or first, if you will. It could look like this...
              <br />
              And then we can conform it to all the relevant interfaces or
              protocols to make it behave more like a real list, or (my
              suggestion) we could just import an existing library that does
              all this for us.
            </aside>
          </section>

          <section>
            <pre
              data-id="nonempty-1"
            ><code class="hljs swift" data-line-numbers="1|5">func average(of list: NonEmpty&lt;Double>) -> Double {
  list.reduce(0, +) / list.count
}

average(of: NonEmpty(head: 1, tail: [2, 3, 4]))
          </code></pre>
            <aside class="notes">
              Putting this to use looks like this. We changed our function to
              expect a non-empty. We'll assume all the hard work has been done
              so that we don't have to change the function body. Then at the
              callsite, there is no way to pass an empty list - we have to
              instantiate an instance of a NonEmpty, which means we have to give
              it a head element. The bug literally doesn't make sense anymore!
               Cool, huh?
            </aside>
          </section>
        </section>

        <!-- ... Closed sets -->

        <section>
          <section>
            <h3>c. Closed sets, discriminated unions</h3>
            <aside class="notes">
              Now for the last way to make invalid state unrepresentable,
               we're going to look at invalid states caused
              by accepting too wide a range of inputs, and how we can tighten
              our definitions with closed sets and discriminated unions.
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="sets-1"
            ><code class="jshl swift" data-line-numbers>struct MyDate {
  let day: Int
  let weekday: Int // 0 = Monday
  let month: Int // 0 = January
}
            </code></pre>
            <aside class="notes">
              Ok here's an easy one. Let's look at this code and point out some issues. 
              <br />
              <ul>
                <li>
                  First off, just because it says in the comments that 0 =
                  Monday, nothing's stopping us from putting a value of 10 or
                  100 or 10,000,000 or minus 4 there, just for a laugh.
                </li>
                <li>
                  But even if we're well-intentioned, we might
                  accidentally get confused about which day of the week is first
                  ‚Äî¬†the week might start on a Monday or on a Sunday depending on where
                  you live or just what you're used to, so this is easy to get wrong.
                </li>
              </ul>
              This one is pretty easy to fix though, using enums.
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="sets-1"
            ><code class="jshl swift" data-line-numbers="1-7|11,12|15">enum Weekday {
  case monday, tuesday, wednesday, // etc...
}

enum Month {
  case january, february, march, // etc...
}

struct MyDate {
  let day: Int
  let weekday: Weekday
  let month: Month
}

MyDate(day: 1, weekday: .monday, month: .march)
            </code></pre>
            <aside class="notes">
              Now we still don't have a nice and ergonomic way to deal with
              dates that only go to 31 for some months and 30 or 28 or 29 for
              others, but... we'll leave that problem alone for this talk.
              <br />
              Enums are quite powerful for this type of thing, because they give
              us the language to define a set of values that only contain exactly
              the values that we consider to be valid. In terms of algebra,
              they're essentially like closed sets.
            </aside>
          </section>

          <section>
            <p>"And" types / Products</p>
            <pre><code>class C {
  let x: Int
  let y: String
}
            </code></pre>

            <aside class="notes">
              Speaking of algebra, here's an interesting concept. Certain types,
              like classes and structs, are "and" types.<br />
              In this example, An instance of class C contains an Int AND a String.
              <br />
              In terms of algebraic types, they are products: the total set of
              all values that C can have is every Int multiplied by every
              String.
            </aside>
          </section>

          <section>
            <p>"Or" types / Sums</p>
            <pre><code>enum E {
  case x(Int)
  case y(String)
}

let eg1 = E.x(2)
let eg2 = E.y("Hello")
            </code></pre>
            <aside class="notes">
              In algebraic type theory, you also get "or" types. They are not
              supported in all programming languages, but you do get them in a
              few.
              <br />
              Unlike structs and classes, an "or" type lets you choose which of
              its members to store in an instance. Here, the total possible
              values that you can represent with enum E is every Int "or" every
              String. In other words, Int + String. They are also called "sum" types.
            </aside>
          </section>

          <section data-auto-animate>
            <p>Use the correct operand</p>
            <pre data-id="sets-result"><code>struct Result {
  let success: String?
  let failure: Error?
}

func request() -> Result {
  // We can do any of these:
  return Result(success: "Hi", failure: nil)
  return Result(success: nil, failure: .badRequest)
  // But also these
  return Result(success: "Hi", failure: .badRequest)
  return Result(success: nil, failure: nil)
}
            </code></pre>
            <aside class="notes">
              Now that we have the terminology for two different type operands,
              namely product and sum, we can think about using the correct ones to
              describe our code. Here's a simple request function that can
              succeed with a String payload, or fail with an error.
              <br />
              If you don't know Swift, you might not know the ? operator;
              it makes the value an optional, and the optional
              String and optional Error are both "or" types, or sum types.
              Success can either be a String OR nil. And failure can either be
              an error OR nil. So we're off to a good start!
              <br />
              However, the containing type here is a struct, which means it's an
              "and" or product type. Result can contain not just a 
              success OR a failure,
              but also a success AND a failure, as well as neither! Some of
              those combinations just don't make sense, so perhaps result should have been an
              "or" type instead?
            </aside>
          </section>

          <section data-auto-animate>
            <p>Use the correct operand</p>
            <pre data-id="sets-result"><code>enum Result {
  case success(String)
  case failure(Error)
}

func request() -> Result {
  // Now, we can only do these:
  return .success("Hi")
  return .failure(.badRequest)
}
            </code></pre>
            <aside class="notes">
              Here we changed it to an enum, which is an "or" or "sum" type. Now, our
              result can only be in one of two states - it can only contain a
              success string, or a failure error, but not both, and not neither.
              In fact, Swift has a built-in type called Result that is implemented a lot like this,
              because this is actually the correct way to represent this concept in code.
            </aside>
          </section>

          <section>
            <p>"Or" types in some languages</p>
            <ul>
              <li>Swift: enums with associated types</li>
              <li>Kotlin: sealed classes</li>
              <li>Rust: enums with fields (?)</li>
              <li>F#: discriminated unions</li>
              <li>Haskell: algebraic data types</li>
            </ul>
          </section>
          <aside class="notes">
            Once you understand it and get used to it, it seems like such a
            fundamental feature that it's quite baffling that it's not
            universally supported by all languages.
            <br />
            Here are some languages that I believe support this concept in some
            shape or form. It's much more common in functional languages, as you
            might imagine, because the notion of algebraic types is more math-y
            than Java-y.
            <br />
            So unfortunately, depending on your job, this might not be available
            to you. But hopefully it helps you to know that this concept exists;
            it might still influence your thoughts around code and software
            design!
          </aside>
        </section>

        <section>
          <h1>Summary</h1>
          <ul class="r-fit-text">
            <li>Language is linked to understanding (?)</li>
            <li>In code, it matters how we say it</li>
            <li>Fix bugs preemptively by making them unrepresentable</li>
            <li>
              Non-interchangebility of concepts can be enforced at the type
              level
            </li>
            <li>
              Values can be guaranteed to be non-negative or non-empty by using
              types
            </li>
            <li>Closed sets narrow down possible values to only valid ones</li>
            <li>
              Algebraic "and" and "or" (product and sum) types help us correctly
              express state
            </li>
          </ul>
          <aside class="notes">
            So that's our time! What have we talked about today?
            <ul>
              <li>
                Language seems to be very deeply linked to how we understand
                things, and the way we express concepts seems to matter
              </li>
              <li>
                This extends to the code we write, and there are many possible
                nuances in how we code, so we should spare some effort to think
                about how we're expressing our programs
              </li>
            </ul>
          </aside>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
